/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef fileSimple_TYPES_H
#define fileSimple_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>



namespace thriftTest {

typedef struct _structure__isset {
  _structure__isset() : att1(false), att2(false), att3(false), att4(false), att5(false) {}
  bool att1;
  bool att2;
  bool att3;
  bool att4;
  bool att5;
} _structure__isset;

class structure {
 public:

  static const char* ascii_fingerprint; // = "18BB90904A19379815A9A295B251B2BB";
  static const uint8_t binary_fingerprint[16]; // = {0x18,0xBB,0x90,0x90,0x4A,0x19,0x37,0x98,0x15,0xA9,0xA2,0x95,0xB2,0x51,0xB2,0xBB};

  structure() : att1(0), att2(), att3(0), att4(0), att5(0) {
  }

  virtual ~structure() throw() {}

  int32_t att1;
  std::string att2;
  double att3;
  double att4;
  bool att5;

  _structure__isset __isset;

  void __set_att1(const int32_t val) {
    att1 = val;
  }

  void __set_att2(const std::string& val) {
    att2 = val;
  }

  void __set_att3(const double val) {
    att3 = val;
  }

  void __set_att4(const double val) {
    att4 = val;
  }

  void __set_att5(const bool val) {
    att5 = val;
  }

  bool operator == (const structure & rhs) const
  {
    if (!(att1 == rhs.att1))
      return false;
    if (!(att2 == rhs.att2))
      return false;
    if (!(att3 == rhs.att3))
      return false;
    if (!(att4 == rhs.att4))
      return false;
    if (!(att5 == rhs.att5))
      return false;
    return true;
  }
  bool operator != (const structure &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const structure & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(structure &a, structure &b);

} // namespace

#endif
